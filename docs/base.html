<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>idiota.base API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>idiota.base</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import itertools
import operator
import os
import string
from collections import deque, namedtuple

from . import data
from . import diff

def init ():
    data.init ()
    data.update_ref (&#39;HEAD&#39;, data.RefValue (symbolic=True, value=&#39;refs/heads/master&#39;))


def write_tree ():
    # Index is flat, we need it as a tree of dicts
    index_as_tree = {}
    with data.get_index () as index:
        for path, oid in index.items ():
            path = path.split (&#39;/&#39;)
            dirpath, filename = path[:-1], path[-1]

            current = index_as_tree
            # Find the dict for the directory of this file
            for dirname in dirpath:
                current = current.setdefault (dirname, {})
            current[filename] = oid

    def write_tree_recursive (tree_dict):
        entries = []
        for name, value in tree_dict.items ():
            if type (value) is dict:
                type_ = &#39;tree&#39;
                oid = write_tree_recursive (value)
            else:
                type_ = &#39;blob&#39;
                oid = value
            entries.append ((name, oid, type_))

        tree = &#39;&#39;.join (f&#39;{type_} {oid} {name}\n&#39;
                        for name, oid, type_
                        in sorted (entries))
        return data.hash_object (tree.encode (), &#39;tree&#39;)

    return write_tree_recursive (index_as_tree)

def _iter_tree_entries (oid):
    if not oid:
        return
    tree = data.get_object (oid, &#39;tree&#39;)
    for entry in tree.decode ().splitlines ():
        type_, oid, name = entry.split (&#39; &#39;, 2)
        yield type_, oid, name


def get_tree (oid, base_path=&#39;&#39;):
    result = {}
    for type_, oid, name in _iter_tree_entries (oid):
        assert &#39;/&#39; not in name
        assert name not in (&#39;..&#39;, &#39;.&#39;)
        path = base_path + name
        if type_ == &#39;blob&#39;:
            result[path] = oid
        elif type_ == &#39;tree&#39;:
            result.update (get_tree (oid, f&#39;{path}/&#39;))
        else:
            assert False, f&#39;Unknown tree entry {type_}&#39;
    return result

def get_working_tree ():
    result = {}
    for root, _, filenames in os.walk (&#39;.&#39;):
        for filename in filenames:
            path = os.path.relpath (f&#39;{root}/{filename}&#39;)
            if is_ignored (path) or not os.path.isfile (path):
                continue
            with open (path, &#39;rb&#39;) as f:
                result[path] = data.hash_object (f.read ())
    return result

def get_index_tree ():
    with data.get_index () as index:
        return index



def _empty_current_directory ():
    for root, _, filenames in os.walk (&#39;.&#39;):
        for filename in filenames:
            path = os.path.relpath (f&#39;{root}/{filename}&#39;)
            if is_ignored (path) or not os.path.isfile (path):
                continue
            os.remove (path)


def read_tree (tree_oid, update_working=False):
    with data.get_index () as index:
        index.clear ()
        index.update (get_tree (tree_oid))

        if update_working:
            _checkout_index (index)


def read_tree_merged (t_base, t_HEAD, t_other, update_working=False):
    with data.get_index () as index:
        index.clear ()
        index.update (diff.merge_trees (
            get_tree (t_base),
            get_tree (t_HEAD),
            get_tree (t_other)
        ))

        if update_working:
            _checkout_index (index)


def _checkout_index (index):
    _empty_current_directory ()
    for path, oid in index.items ():
        os.makedirs (os.path.dirname (f&#39;./{path}&#39;), exist_ok=True)
        with open (path, &#39;wb&#39;) as f:
            f.write (data.get_object (oid, &#39;blob&#39;))

def commit (message):
    commit = f&#39;tree {write_tree ()}\n&#39;

    HEAD = data.get_ref (&#39;HEAD&#39;).value

    if HEAD:
        commit += f&#39;parent {HEAD}\n&#39;
    MERGE_HEAD = data.get_ref (&#39;MERGE_HEAD&#39;).value
    if MERGE_HEAD:
        commit += f&#39;parent {MERGE_HEAD}\n&#39;
        data.delete_ref (&#39;MERGE_HEAD&#39;, deref=False)

    commit += &#39;\n&#39;
    commit += f&#39;{message}\n&#39;

    oid = data.hash_object (commit.encode (), &#39;commit&#39;)

    data.update_ref (&#39;HEAD&#39;, data.RefValue (symbolic=False, value=oid))
    
    return oid

def checkout (name):
    oid = get_oid (name)
    commit = get_commit (oid)
    read_tree (commit.tree, update_working=True)


    if is_branch (name):
        HEAD = data.RefValue (symbolic=True, value=f&#39;refs/heads/{name}&#39;)
    else:
        HEAD = data.RefValue (symbolic=False, value=oid)

    data.update_ref (&#39;HEAD&#39;, HEAD, deref=False)

def reset (oid):
    data.update_ref (&#39;HEAD&#39;, data.RefValue (symbolic=False, value=oid))

def merge (other):
    HEAD = data.get_ref (&#39;HEAD&#39;).value
    assert HEAD
    merge_base = get_merge_base (other, HEAD)
    c_other = get_commit (other)

    # Handle fast-forward merge
    if merge_base == HEAD:
        read_tree (c_other.tree, update_working=True)
        data.update_ref (&#39;HEAD&#39;,
                         data.RefValue (symbolic=False, value=other))
        print (&#39;Fast-forward merge, no need to commit&#39;)
        return

    data.update_ref (&#39;MERGE_HEAD&#39;, data.RefValue (symbolic=False, value=other))

    c_base = get_commit (merge_base)
    c_HEAD = get_commit (HEAD)
    read_tree_merged (c_base.tree, c_HEAD.tree, c_other.tree, update_working=True)
    print (&#39;Merged in working tree\nPlease commit&#39;)


def get_merge_base (oid1, oid2):
    parents1 = list (iter_commits_and_parents ({oid1}))

    for oid in iter_commits_and_parents ({oid2}):
        if oid in parents1:
            return oid

def create_tag (name, oid):
    data.update_ref (f&#39;refs/tags/{name}&#39;, data.RefValue (symbolic=False, value=oid))

def create_branch (name, oid):
    data.update_ref (f&#39;refs/heads/{name}&#39;, data.RefValue (symbolic=False, value=oid))

def iter_branch_names ():
    for refname, _ in data.iter_refs (&#39;refs/heads/&#39;):
        yield os.path.relpath (refname, &#39;refs/heads/&#39;)

def is_branch (branch):
    return data.get_ref (f&#39;refs/heads/{branch}&#39;).value is not None

def get_branch_name ():
    HEAD = data.get_ref (&#39;HEAD&#39;, deref=False)
    if not HEAD.symbolic:
        return None
    HEAD = HEAD.value
    assert HEAD.startswith (&#39;refs/heads/&#39;)
    return os.path.relpath (HEAD, &#39;refs/heads&#39;)


Commit = namedtuple (&#39;Commit&#39;, [&#39;tree&#39;, &#39;parents&#39;, &#39;message&#39;])

def get_commit (oid):
    parents = []

    commit = data.get_object (oid, &#39;commit&#39;).decode ()
    lines = iter (commit.splitlines ())
    for line in itertools.takewhile (operator.truth, lines):
        key, value = line.split (&#39; &#39;, 1)
        if key == &#39;tree&#39;:
            tree = value
        elif key == &#39;parent&#39;:
            parents = []
        else:
            assert False, f&#39;Unknown field {key}&#39;

    message = &#39;\n&#39;.join (lines)
    return Commit (tree=tree, parents=parents, message=message)

def iter_commits_and_parents (oids):
    oids = deque (oids)
    visited = set ()

    while oids:
        oid = oids.popleft ()
        if not oid or oid in visited:
            continue
        visited.add (oid)
        yield oid

        commit = get_commit (oid)
        # Return first parent next
        oids.extendleft (commit.parents[:1])
        # Return other parents later
        oids.extend (commit.parents[1:])

def iter_objects_in_commits (oids):
    # N.B. Must yield the oid before acccessing it (to allow caller to fetch it
    # if needed)

    visited = set ()
    def iter_objects_in_tree (oid):
        visited.add (oid)
        yield oid
        for type_, oid, _ in _iter_tree_entries (oid):
            if oid not in visited:
                if type_ == &#39;tree&#39;:
                    yield from iter_objects_in_tree (oid)
                else:
                    visited.add (oid)
                    yield oid

    for oid in iter_commits_and_parents (oids):
        yield oid
        commit = get_commit (oid)
        if commit.tree not in visited:
            yield from iter_objects_in_tree (commit.tree)


def get_oid (name):
    if name == &#39;@&#39;: name = &#39;HEAD&#39;

    refs_to_try = [
        f&#39;{name}&#39;,
        f&#39;refs/{name}&#39;,
        f&#39;refs/tags/{name}&#39;,
        f&#39;refs/heads/{name}&#39;,
    ]
    for ref in refs_to_try:
        if data.get_ref (ref, deref=False).value:
            return data.get_ref (ref).value

    # Name is SHA1
    is_hex = all (c in string.hexdigits for c in name)
    if len (name) == 40 and is_hex:
        return name

    assert False, f&#39;Unknown name {name}&#39;


def add (filenames):

    def add_file (filename):
        # Normalize path
        filename = os.path.relpath (filename)
        with open (filename, &#39;rb&#39;) as f:
            oid = data.hash_object (f.read ())
        index[filename] = oid

    def add_directory (dirname):
        for root, _, filenames in os.walk (dirname):
            for filename in filenames:
                # Normalize path
                path = os.path.relpath (f&#39;{root}/{filename}&#39;)
                if is_ignored (path) or not os.path.isfile (path):
                    continue
                add_file (path)

    with data.get_index () as index:
        for name in filenames:
            if os.path.isfile (name):
                add_file (name)
            elif os.path.isdir (name):
                add_directory (name)

def is_ignored (path):
    return &#39;.idiota&#39; in path.split (&#39;/&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="idiota.base.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>filenames)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add (filenames):

    def add_file (filename):
        # Normalize path
        filename = os.path.relpath (filename)
        with open (filename, &#39;rb&#39;) as f:
            oid = data.hash_object (f.read ())
        index[filename] = oid

    def add_directory (dirname):
        for root, _, filenames in os.walk (dirname):
            for filename in filenames:
                # Normalize path
                path = os.path.relpath (f&#39;{root}/{filename}&#39;)
                if is_ignored (path) or not os.path.isfile (path):
                    continue
                add_file (path)

    with data.get_index () as index:
        for name in filenames:
            if os.path.isfile (name):
                add_file (name)
            elif os.path.isdir (name):
                add_directory (name)</code></pre>
</details>
</dd>
<dt id="idiota.base.checkout"><code class="name flex">
<span>def <span class="ident">checkout</span></span>(<span>name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checkout (name):
    oid = get_oid (name)
    commit = get_commit (oid)
    read_tree (commit.tree, update_working=True)


    if is_branch (name):
        HEAD = data.RefValue (symbolic=True, value=f&#39;refs/heads/{name}&#39;)
    else:
        HEAD = data.RefValue (symbolic=False, value=oid)

    data.update_ref (&#39;HEAD&#39;, HEAD, deref=False)</code></pre>
</details>
</dd>
<dt id="idiota.base.commit"><code class="name flex">
<span>def <span class="ident">commit</span></span>(<span>message)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def commit (message):
    commit = f&#39;tree {write_tree ()}\n&#39;

    HEAD = data.get_ref (&#39;HEAD&#39;).value

    if HEAD:
        commit += f&#39;parent {HEAD}\n&#39;
    MERGE_HEAD = data.get_ref (&#39;MERGE_HEAD&#39;).value
    if MERGE_HEAD:
        commit += f&#39;parent {MERGE_HEAD}\n&#39;
        data.delete_ref (&#39;MERGE_HEAD&#39;, deref=False)

    commit += &#39;\n&#39;
    commit += f&#39;{message}\n&#39;

    oid = data.hash_object (commit.encode (), &#39;commit&#39;)

    data.update_ref (&#39;HEAD&#39;, data.RefValue (symbolic=False, value=oid))
    
    return oid</code></pre>
</details>
</dd>
<dt id="idiota.base.create_branch"><code class="name flex">
<span>def <span class="ident">create_branch</span></span>(<span>name, oid)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_branch (name, oid):
    data.update_ref (f&#39;refs/heads/{name}&#39;, data.RefValue (symbolic=False, value=oid))</code></pre>
</details>
</dd>
<dt id="idiota.base.create_tag"><code class="name flex">
<span>def <span class="ident">create_tag</span></span>(<span>name, oid)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_tag (name, oid):
    data.update_ref (f&#39;refs/tags/{name}&#39;, data.RefValue (symbolic=False, value=oid))</code></pre>
</details>
</dd>
<dt id="idiota.base.get_branch_name"><code class="name flex">
<span>def <span class="ident">get_branch_name</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_branch_name ():
    HEAD = data.get_ref (&#39;HEAD&#39;, deref=False)
    if not HEAD.symbolic:
        return None
    HEAD = HEAD.value
    assert HEAD.startswith (&#39;refs/heads/&#39;)
    return os.path.relpath (HEAD, &#39;refs/heads&#39;)</code></pre>
</details>
</dd>
<dt id="idiota.base.get_commit"><code class="name flex">
<span>def <span class="ident">get_commit</span></span>(<span>oid)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_commit (oid):
    parents = []

    commit = data.get_object (oid, &#39;commit&#39;).decode ()
    lines = iter (commit.splitlines ())
    for line in itertools.takewhile (operator.truth, lines):
        key, value = line.split (&#39; &#39;, 1)
        if key == &#39;tree&#39;:
            tree = value
        elif key == &#39;parent&#39;:
            parents = []
        else:
            assert False, f&#39;Unknown field {key}&#39;

    message = &#39;\n&#39;.join (lines)
    return Commit (tree=tree, parents=parents, message=message)</code></pre>
</details>
</dd>
<dt id="idiota.base.get_index_tree"><code class="name flex">
<span>def <span class="ident">get_index_tree</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_index_tree ():
    with data.get_index () as index:
        return index</code></pre>
</details>
</dd>
<dt id="idiota.base.get_merge_base"><code class="name flex">
<span>def <span class="ident">get_merge_base</span></span>(<span>oid1, oid2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_merge_base (oid1, oid2):
    parents1 = list (iter_commits_and_parents ({oid1}))

    for oid in iter_commits_and_parents ({oid2}):
        if oid in parents1:
            return oid</code></pre>
</details>
</dd>
<dt id="idiota.base.get_oid"><code class="name flex">
<span>def <span class="ident">get_oid</span></span>(<span>name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_oid (name):
    if name == &#39;@&#39;: name = &#39;HEAD&#39;

    refs_to_try = [
        f&#39;{name}&#39;,
        f&#39;refs/{name}&#39;,
        f&#39;refs/tags/{name}&#39;,
        f&#39;refs/heads/{name}&#39;,
    ]
    for ref in refs_to_try:
        if data.get_ref (ref, deref=False).value:
            return data.get_ref (ref).value

    # Name is SHA1
    is_hex = all (c in string.hexdigits for c in name)
    if len (name) == 40 and is_hex:
        return name

    assert False, f&#39;Unknown name {name}&#39;</code></pre>
</details>
</dd>
<dt id="idiota.base.get_tree"><code class="name flex">
<span>def <span class="ident">get_tree</span></span>(<span>oid, base_path='')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tree (oid, base_path=&#39;&#39;):
    result = {}
    for type_, oid, name in _iter_tree_entries (oid):
        assert &#39;/&#39; not in name
        assert name not in (&#39;..&#39;, &#39;.&#39;)
        path = base_path + name
        if type_ == &#39;blob&#39;:
            result[path] = oid
        elif type_ == &#39;tree&#39;:
            result.update (get_tree (oid, f&#39;{path}/&#39;))
        else:
            assert False, f&#39;Unknown tree entry {type_}&#39;
    return result</code></pre>
</details>
</dd>
<dt id="idiota.base.get_working_tree"><code class="name flex">
<span>def <span class="ident">get_working_tree</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_working_tree ():
    result = {}
    for root, _, filenames in os.walk (&#39;.&#39;):
        for filename in filenames:
            path = os.path.relpath (f&#39;{root}/{filename}&#39;)
            if is_ignored (path) or not os.path.isfile (path):
                continue
            with open (path, &#39;rb&#39;) as f:
                result[path] = data.hash_object (f.read ())
    return result</code></pre>
</details>
</dd>
<dt id="idiota.base.init"><code class="name flex">
<span>def <span class="ident">init</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init ():
    data.init ()
    data.update_ref (&#39;HEAD&#39;, data.RefValue (symbolic=True, value=&#39;refs/heads/master&#39;))</code></pre>
</details>
</dd>
<dt id="idiota.base.is_branch"><code class="name flex">
<span>def <span class="ident">is_branch</span></span>(<span>branch)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_branch (branch):
    return data.get_ref (f&#39;refs/heads/{branch}&#39;).value is not None</code></pre>
</details>
</dd>
<dt id="idiota.base.is_ignored"><code class="name flex">
<span>def <span class="ident">is_ignored</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_ignored (path):
    return &#39;.idiota&#39; in path.split (&#39;/&#39;)</code></pre>
</details>
</dd>
<dt id="idiota.base.iter_branch_names"><code class="name flex">
<span>def <span class="ident">iter_branch_names</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_branch_names ():
    for refname, _ in data.iter_refs (&#39;refs/heads/&#39;):
        yield os.path.relpath (refname, &#39;refs/heads/&#39;)</code></pre>
</details>
</dd>
<dt id="idiota.base.iter_commits_and_parents"><code class="name flex">
<span>def <span class="ident">iter_commits_and_parents</span></span>(<span>oids)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_commits_and_parents (oids):
    oids = deque (oids)
    visited = set ()

    while oids:
        oid = oids.popleft ()
        if not oid or oid in visited:
            continue
        visited.add (oid)
        yield oid

        commit = get_commit (oid)
        # Return first parent next
        oids.extendleft (commit.parents[:1])
        # Return other parents later
        oids.extend (commit.parents[1:])</code></pre>
</details>
</dd>
<dt id="idiota.base.iter_objects_in_commits"><code class="name flex">
<span>def <span class="ident">iter_objects_in_commits</span></span>(<span>oids)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_objects_in_commits (oids):
    # N.B. Must yield the oid before acccessing it (to allow caller to fetch it
    # if needed)

    visited = set ()
    def iter_objects_in_tree (oid):
        visited.add (oid)
        yield oid
        for type_, oid, _ in _iter_tree_entries (oid):
            if oid not in visited:
                if type_ == &#39;tree&#39;:
                    yield from iter_objects_in_tree (oid)
                else:
                    visited.add (oid)
                    yield oid

    for oid in iter_commits_and_parents (oids):
        yield oid
        commit = get_commit (oid)
        if commit.tree not in visited:
            yield from iter_objects_in_tree (commit.tree)</code></pre>
</details>
</dd>
<dt id="idiota.base.merge"><code class="name flex">
<span>def <span class="ident">merge</span></span>(<span>other)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge (other):
    HEAD = data.get_ref (&#39;HEAD&#39;).value
    assert HEAD
    merge_base = get_merge_base (other, HEAD)
    c_other = get_commit (other)

    # Handle fast-forward merge
    if merge_base == HEAD:
        read_tree (c_other.tree, update_working=True)
        data.update_ref (&#39;HEAD&#39;,
                         data.RefValue (symbolic=False, value=other))
        print (&#39;Fast-forward merge, no need to commit&#39;)
        return

    data.update_ref (&#39;MERGE_HEAD&#39;, data.RefValue (symbolic=False, value=other))

    c_base = get_commit (merge_base)
    c_HEAD = get_commit (HEAD)
    read_tree_merged (c_base.tree, c_HEAD.tree, c_other.tree, update_working=True)
    print (&#39;Merged in working tree\nPlease commit&#39;)</code></pre>
</details>
</dd>
<dt id="idiota.base.read_tree"><code class="name flex">
<span>def <span class="ident">read_tree</span></span>(<span>tree_oid, update_working=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_tree (tree_oid, update_working=False):
    with data.get_index () as index:
        index.clear ()
        index.update (get_tree (tree_oid))

        if update_working:
            _checkout_index (index)</code></pre>
</details>
</dd>
<dt id="idiota.base.read_tree_merged"><code class="name flex">
<span>def <span class="ident">read_tree_merged</span></span>(<span>t_base, t_HEAD, t_other, update_working=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_tree_merged (t_base, t_HEAD, t_other, update_working=False):
    with data.get_index () as index:
        index.clear ()
        index.update (diff.merge_trees (
            get_tree (t_base),
            get_tree (t_HEAD),
            get_tree (t_other)
        ))

        if update_working:
            _checkout_index (index)</code></pre>
</details>
</dd>
<dt id="idiota.base.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>oid)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset (oid):
    data.update_ref (&#39;HEAD&#39;, data.RefValue (symbolic=False, value=oid))</code></pre>
</details>
</dd>
<dt id="idiota.base.write_tree"><code class="name flex">
<span>def <span class="ident">write_tree</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_tree ():
    # Index is flat, we need it as a tree of dicts
    index_as_tree = {}
    with data.get_index () as index:
        for path, oid in index.items ():
            path = path.split (&#39;/&#39;)
            dirpath, filename = path[:-1], path[-1]

            current = index_as_tree
            # Find the dict for the directory of this file
            for dirname in dirpath:
                current = current.setdefault (dirname, {})
            current[filename] = oid

    def write_tree_recursive (tree_dict):
        entries = []
        for name, value in tree_dict.items ():
            if type (value) is dict:
                type_ = &#39;tree&#39;
                oid = write_tree_recursive (value)
            else:
                type_ = &#39;blob&#39;
                oid = value
            entries.append ((name, oid, type_))

        tree = &#39;&#39;.join (f&#39;{type_} {oid} {name}\n&#39;
                        for name, oid, type_
                        in sorted (entries))
        return data.hash_object (tree.encode (), &#39;tree&#39;)

    return write_tree_recursive (index_as_tree)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="idiota.base.Commit"><code class="flex name class">
<span>class <span class="ident">Commit</span></span>
<span>(</span><span>tree, parents, message)</span>
</code></dt>
<dd>
<div class="desc"><p>Commit(tree, parents, message)</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="idiota.base.Commit.message"><code class="name">var <span class="ident">message</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
<dt id="idiota.base.Commit.parents"><code class="name">var <span class="ident">parents</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="idiota.base.Commit.tree"><code class="name">var <span class="ident">tree</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="idiota" href="index.html">idiota</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="idiota.base.add" href="#idiota.base.add">add</a></code></li>
<li><code><a title="idiota.base.checkout" href="#idiota.base.checkout">checkout</a></code></li>
<li><code><a title="idiota.base.commit" href="#idiota.base.commit">commit</a></code></li>
<li><code><a title="idiota.base.create_branch" href="#idiota.base.create_branch">create_branch</a></code></li>
<li><code><a title="idiota.base.create_tag" href="#idiota.base.create_tag">create_tag</a></code></li>
<li><code><a title="idiota.base.get_branch_name" href="#idiota.base.get_branch_name">get_branch_name</a></code></li>
<li><code><a title="idiota.base.get_commit" href="#idiota.base.get_commit">get_commit</a></code></li>
<li><code><a title="idiota.base.get_index_tree" href="#idiota.base.get_index_tree">get_index_tree</a></code></li>
<li><code><a title="idiota.base.get_merge_base" href="#idiota.base.get_merge_base">get_merge_base</a></code></li>
<li><code><a title="idiota.base.get_oid" href="#idiota.base.get_oid">get_oid</a></code></li>
<li><code><a title="idiota.base.get_tree" href="#idiota.base.get_tree">get_tree</a></code></li>
<li><code><a title="idiota.base.get_working_tree" href="#idiota.base.get_working_tree">get_working_tree</a></code></li>
<li><code><a title="idiota.base.init" href="#idiota.base.init">init</a></code></li>
<li><code><a title="idiota.base.is_branch" href="#idiota.base.is_branch">is_branch</a></code></li>
<li><code><a title="idiota.base.is_ignored" href="#idiota.base.is_ignored">is_ignored</a></code></li>
<li><code><a title="idiota.base.iter_branch_names" href="#idiota.base.iter_branch_names">iter_branch_names</a></code></li>
<li><code><a title="idiota.base.iter_commits_and_parents" href="#idiota.base.iter_commits_and_parents">iter_commits_and_parents</a></code></li>
<li><code><a title="idiota.base.iter_objects_in_commits" href="#idiota.base.iter_objects_in_commits">iter_objects_in_commits</a></code></li>
<li><code><a title="idiota.base.merge" href="#idiota.base.merge">merge</a></code></li>
<li><code><a title="idiota.base.read_tree" href="#idiota.base.read_tree">read_tree</a></code></li>
<li><code><a title="idiota.base.read_tree_merged" href="#idiota.base.read_tree_merged">read_tree_merged</a></code></li>
<li><code><a title="idiota.base.reset" href="#idiota.base.reset">reset</a></code></li>
<li><code><a title="idiota.base.write_tree" href="#idiota.base.write_tree">write_tree</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="idiota.base.Commit" href="#idiota.base.Commit">Commit</a></code></h4>
<ul class="">
<li><code><a title="idiota.base.Commit.message" href="#idiota.base.Commit.message">message</a></code></li>
<li><code><a title="idiota.base.Commit.parents" href="#idiota.base.Commit.parents">parents</a></code></li>
<li><code><a title="idiota.base.Commit.tree" href="#idiota.base.Commit.tree">tree</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>